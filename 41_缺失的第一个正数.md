# 41 缺失的第一个正数

20200323

> 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
>
> 示例 1:
>
> 输入: [1,2,0]
> 输出: 3
> 示例 2:
>
> 输入: [3,4,-1,1]
> 输出: 2
> 示例 3:
>
> 输入: [7,8,9,11,12]
> 输出: 1
> 说明:
>
> 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。
>

题解：

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        nums.push_back(0);
        for(int i=0;i<nums.size();i++){
            while(nums[i]!=i&&nums[i]>0&&nums[i]<nums.size() && nums[i]!=nums[nums[i]]){
                swap(nums[i],nums[nums[i]]);
            }
        }
        for(int i=1;i<nums.size();i++){
            cout<<nums[i]<<endl;
            if(nums[i]!=i){
                return i;
            }
        }
        return nums.size();
    }
};
```

感想：

这题真的挺折腾，想了快三个小时吧，不过最后想出来了办法，写了半天把自己弄糊涂了，实在是不应该，最后在讨论里看到进阶版的思路，就写了下。

一开始的想法就是单纯的把i放在a[i]的位置上，但是a[i]和a[a[i]]的交换方式一直没想好，中间还超时了，搞得焦头烂额的。其实本来也是可行的，就是要维护last 和 now两个下表指针，每次交换完了退回去就行了。

讨论区的大佬表示只要交换前后项直到交换完成或者交换失败即可，其实道理也很简单，看似双重循环，其实里面多换一次外层就可以少换一次，归根结底还是o(n)，挺妙的。

这个故事告诉我们，每次遇到交换的题之类的都可以考虑一下顺序交换，非常方便。